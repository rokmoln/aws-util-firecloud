{"version":3,"sources":["../src/express-middleware.js"],"names":[],"mappings":";;;;;;;;;AAAA;;;;AAEA;;;;AAKO,IAAI,gCAAY,UAAS,EAAT,EAAa;AAClC,SAAO;AAAA,wCAAa,WAAe,GAAG,IAAlB,EAAwB;AAC1C,UAAI,MAAM,KAAK,CAAL,CAAV;AACA,UAAI,MAAM,KAAK,KAAK,MAAL,GAAc,CAAnB,CAAV;;AAEA,UAAI;AACF,cAAM,GAAG,GAAG,IAAN,CAAN;AACD,OAFD,CAEE,OAAO,GAAP,EAAY;AACZ,YAAI,GAAJ,CAAQ,KAAR,CAAc,EAAC,GAAD,EAAd;;AAEA,YAAI,IAAI,GAAJ,CAAQ,GAAR,CAAY,KAAZ,KAAsB,IAAI,GAAJ,CAAQ,GAAR,CAAY,YAAZ,CAAyB,OAAzB,CAA1B,EAA6D;AAC3D;AACA;AACA,kBAAQ,IAAR,CAAa,CAAb;AACD;;AAED,YAAI,IAAI,WAAR,EAAqB;AACnB;AACA;AACA,kBAAQ,IAAR,CAAa,CAAb;AACD;;AAED;AACA;AACA;AACA;AACA,YAAI,QAAQ,IAAI,KAAJ,GAAY,0BAAE,KAAF,CAAQ,IAAI,KAAZ,EAAmB,IAAnB,CAAZ,GAAuC,GAAnD;;AAEA,YAAI,GAAJ,CAAQ,8BAAR,GAAyC,KAAzC;AACA,kCAAE,KAAF,CAAQ,YAAW;AACjB;AACA;AACA;AACA;AACA,kBAAQ,IAAR,CAAa,CAAb;AACD,SAND,EAMG,IANH;;AAQA,YAAI,MAAJ,CAAW,GAAX;AACA,YAAI,GAAJ,CAAQ;AACN,0BAAgB;AADV,SAAR;AAGA,YAAI,IAAJ,CAAS;AACP,gBAAM,aADC;AAEP,iBAAO,uBAFA;AAGP,kBAAQ,GAHD;AAIP,oBAAU,gCAAmB,GAAnB,CAJH;AAKP,oBAAU,aALH;AAMP;AANO,SAAT;AAQD;AACF,KAjDM;;AAAA;AAAA;AAAA;AAAA,OAAP;AAkDD,CAnDM;;kBAqDQ,O","file":"express-middleware.js","sourcesContent":["import _ from 'lodash-firecloud';\n\nimport {\n  asyncHandler,\n  getRequestInstance\n} from './lambda';\n\nexport let bootstrap = function(fn) {\n  return asyncHandler(async function(...args) {\n    let res = args[1];\n    let req = args[args.length - 3];\n\n    try {\n      await fn(...args);\n    } catch (err) {\n      res.log.error({err});\n\n      if (res.ctx.log.level() > res.ctx.log.resolveLevel('TRACE')) {\n        // if no trace is desired, we'd better just exit\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n\n      if (res.headersSent) {\n        // we cannot amend the response anymore\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n\n      // NOTE we prioritize responding with a body that includes error details\n      // and exits on the next call.\n      // The exit is required, in order to guarantee a clean state,\n      // as opposed to the borked one in which the error was triggered.\n      let trace = err.stack ? _.split(err.stack, '\\n') : err;\n\n      res.ctx.callbackWaitsForEmptyEventLoop = false;\n      _.delay(function() {\n        // this will run on the next call,\n        // because calling res.send will immediately freeze the process,\n        // only to be unfrozen by the next call\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }, 1000);\n\n      res.status(500);\n      res.set({\n        'content-type': 'application/problem+json'\n      });\n      res.send({\n        type: 'about:blank',\n        title: 'Internal Server Error',\n        status: 500,\n        instance: getRequestInstance(req),\n        renderer: 'lambda-util',\n        trace\n      });\n    }\n  });\n};\n\nexport default exports;\n"]}