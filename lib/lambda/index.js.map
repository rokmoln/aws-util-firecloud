{"version":3,"sources":["../../src/lambda/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import _ from 'lodash-firecloud';\n// eslint-disable-next-line import/no-unresolved\nimport awsLambda from 'aws-lambda';\nimport inspect from './inspect';\n\nimport {\n  LambdaContext,\n  LambdaEvent,\n  LambdaHandler,\n  LambdaResult,\n  PackageJson\n} from '../types';\n\nimport {\n  merge as mergeEnvCtx\n} from './env-ctx';\n\nimport {\n  setup as setupLogger\n} from './logger';\n\nimport {\n  MinLog\n} from 'minlog';\n\nlet _logger = undefined as MinLog;\n\nlet _maybeFlushMinlog = async function(): Promise<void> {\n  if (_.isUndefined(_logger)) {\n    return;\n  }\n  let logger = _logger;\n  _logger = undefined;\n  try {\n    await logger.flush();\n  } catch (minlogFlushErr) {\n    // eslint-disable-next-line no-console\n    console.error('FATAL MinLog.flush');\n    // eslint-disable-next-line no-console\n    console.error(minlogFlushErr.stack);\n  }\n};\n\nlet _cleanup = async function({ctx}: {\n  ctx: LambdaContext;\n}): Promise<void> {\n  if (_.isUndefined(global.gc)) {\n    return;\n  }\n  await ctx.log.trackTime(\n    'Garbage collection on demand...',\n    async function() {\n      global.gc();\n    }\n  );\n};\n\n// eslint-disable-next-line max-params\nlet _bootstrap = async function <\n  TEvent extends LambdaEvent,\n  TResult extends LambdaResult\n>(\n  fn: LambdaHandler<TEvent, TResult>,\n  e: TEvent,\n  ctx: LambdaContext,\n  pkg: PackageJson\n): Promise<TResult> {\n  // temporary logger\n  _logger = setupLogger({ctx});\n\n  await ctx.log.trackTime(\n    'Merging env ctx...',\n    async function() {\n      await mergeEnvCtx({e, ctx, pkg});\n    }\n  );\n\n  await ctx.log.trackTime(\n    'Setting up logger...',\n    async function() {\n      setupLogger({ctx});\n      ctx.log.trace(`Logger started with level=${ctx.log.level()}`, {\n        e,\n        ctx\n      });\n    }\n  );\n\n  await ctx.log.trackTime(\n    'Inspecting...',\n    async function() {\n      await inspect({ctx});\n    }\n  );\n\n  let result: TResult;\n  await ctx.log.trackTime(\n    'Running fn...',\n    async function() {\n      result = await fn(e, ctx);\n      ctx.log.trace('Fn result:', {\n        result\n      });\n    }\n  );\n\n  // don't wait for cleanup on purpose\n  _.defer(_.asyncCb(async function() {\n    await _cleanup({ctx});\n  }));\n\n  return result;\n};\n\nexport let getRequestInstance = function({ctx}: {\n  ctx: LambdaContext;\n}): string {\n  return `${ctx.invokedFunctionArn}#request:${ctx.awsRequestId}`;\n};\n\n/* eslint-disable no-console */\nexport let bootstrap = function <\n  TEvent extends LambdaEvent,\n  TResult extends LambdaResult\n>(fn: LambdaHandler<TEvent, TResult>, {\n  pkg\n}: {\n  pkg: PackageJson;\n}): awsLambda.Handler {\n  process.on('uncaughtException', function(err: Error) {\n    _maybeFlushMinlog().finally(function() {\n      console.error('FATAL uncaughtException');\n      console.error(err.stack);\n      // eslint-disable-next-line no-process-exit\n      process.exit(1);\n    });\n  });\n\n  process.on('unhandledRejection', function(err: Error) {\n    _maybeFlushMinlog().finally(function() {\n      console.error('FATAL unhandledRejection');\n      console.error(err.stack);\n      // eslint-disable-next-line no-process-exit\n      process.exit(1);\n    });\n  });\n\n  return async function(e: TEvent, ctx: LambdaContext, awsNext: awsLambda.Callback) {\n    let result: TResult;\n    let err: Error;\n\n    try {\n      result = await _bootstrap<TEvent, TResult>(fn, e, ctx, pkg);\n    } catch (err2) {\n      err = err2;\n    }\n\n    if (_.isDefined(_logger)) {\n      let logger = _logger;\n      _logger = undefined;\n      try {\n        await logger.flush();\n      } catch (minlogFlushErr) {\n        console.error('FATAL MinLog.flush');\n        console.error(minlogFlushErr.stack);\n      }\n    }\n\n    if (_.isDefined(err)) {\n      // proxying the err to awsNext would not reset state (kill lambda)\n      // if (_.isFunction(awsNext)) {\n      //   return awsNext(err);\n      // } else {\n      //   throw err;\n      // }\n\n      console.error('FATAL try-catch-lambda-bootstrap');\n      console.error(err.stack);\n      // eslint-disable-next-line no-process-exit\n      process.exit(1);\n    }\n\n    if (_.isFunction(awsNext)) {\n      awsNext(undefined, result);\n    } else {\n      return result;\n    }\n  };\n  /* eslint-enable no-console */\n};\n"]}